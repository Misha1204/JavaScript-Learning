1) OOP არის პროგრამული პარადიგმა, რომელიც დაფუძნებულია ობიექტების კონცეპტებზე.
2) CLASS - წარმოადგენს ერთგვარ მაკეტს (Blueprint), რომლისგანაც შეგვიძლია შექმნათ ახალი ობიექტები. თავად კლასი არ არის ობიექტი და მისი საშუალებით
შეგვიძლია შევქმნათ იმდენი Instance ანუ ობიექტი, რამდენიც გვინდა.
3) Instance - კი უკვე წარმოადგენს ნამდვილ ობიექტს, რომელიც შეიქმნა კლასის საშუალებით და ამავე კლასში განსაზღვრული მონაცემებით.
4) JavaScript - ში, თითოეული ობიექტი უკავშირდება პროტოტიპ ობიექტს, რომელიც განსხვავებულია კლასებს შორის Inheritance - სგან. იქ კლასი იღებდა
მშობელი კლასის მეთოდებს, ხოლო აღნიშნულ შემთხვევაში, თავად ობიექტი იღებს კლასის მეთოდებს.

##################################################################################################################################################

კლასები | Classes
##################
1) ობიექტზე ორიენტირებულ პროგრამირებაში შევხვდებით 4 ძირითად პრინციპს. ეს პრინციპებია: Abstraction, Encapsulation, Inheritance, Polymorphism.
2) Abstraction - იმ დეტალების დამალვა ან დაიგნორება, რომლებსაც არ აქვთ მნიშვნელობა.
3) Encapsulation - Property - ების და მეთოდების პრივატულად შენახვა, კლასის შიგნით, ისე, რომ ისინი არ იყოს ხელმისაწვდომი კლასის გარეთ.
ენკაფსულაციის საშუალებით, ვიცავთ კლასის შიგნით არსებულ კოდს, გარე კოდის მანიპულაციისგან.
4) Inheritance - როდესაც ორი კლასი ძალიან ახლოს დგას ერთმანეთთან, შეგვიძლია გამოვიყენოთ Inheritance, რაც გულისხმობს, რომ შვილობილი კლასი,
მშობლისგან წამოიღებს Property - ებს და მეთოდებს.
5) Polymorphism - შვილობილ კლასს, შეუძლია გადაწეროს ის მეთოდი, რომელიც მემკვიდრეობით მიიღო მშობელი კლასისგან. ამისათვის, საჭიროა, შვილობილ
კლასში გავწერთო იგივე სახელწოდების მქონე მეთოდი, რომელსაც შევუცვლით ლოგიკას ჩვენი სურვილისამებრ.

##################################################################################################################################################

არსებობს 3 გზა იმისათვის, რომ ჯავასკრიპტში დავნერგოთ Prototypal Inheritance

1) Constructor functions:
    ა. ფუნქციისგან ობიექტის შექმნის ტექნიკა.
    ბ. ეს არის გზა, რომლის საშუალებითაც იმპლემენტირდება ჩაშენებული ობიექტები: Arrays, Maps, Sets...
    გ. ძველი გზა
2) ES6 Classes:
    ა. თანამედროვე გზა.
    ბ. სცენის უკან ES6 Class - ები მოქმედებს ისევე, როგორც Constructor function - ები.
3) Object.create():
    ა. ყვლაზე მარტივი გზა იმისათვის, რომ ობიექტი დავუკავშიროთ პროტოტიპ ობიექტს.

###################################################################################################################################################

Prototype Chain
###############

როდესაც ვქმნით კონსტრუქტორ ფუნქციას, მას აქვს თავისი პროტოტიპი, მაგალითად: ზემოაღნიშნულ კოდში, კონსტრუქტორ ფუნქციის Person - ის პროტოტიპი
არის Person.prototype, თუმცა უნდა გავიხსენოთ, რომ Person.prototype არის ობიექტი და ჯავასკრიპტში, თითოეულ ობიექტს აქვს თავისი პროტოტიპი,
აღნიშნულ შემთხვევაში Person.prototype - ის პროტოტიპს წარმოადგენს Object.prototype.

###################################################################################################################################################

Arrays
######

როდესაც ჩვენ ვქმნით სიას მაგ: const array = [1, 2, 3, 4, 5], აღნიშნულ შემთხვევაში, ეს იგივეა რაც new Array(1, 2, 3, 4, 5). new Array წარმოადგენს კონტრუქტორ
ფუნქციას, რომელსაც გააჩნია თავისი პროტოტიპი, Array.prototype. მასში გაწერილია ყველა ის მეთოდი, რომელსაც ჩვენ ვიყენებთ სიასთან მუშაობის დროს,
როგორიცაა (pop(), push(), filter() და ა. შ.). იმ შემთხვევაში, თუ ჩვენ გვინდა რომ სიის მეთოდებში დავამატოთ ახალი ფუნქცია/მეთოდი, აღნიშნულ შემთხვევაში
უბრალოდ შეგვიძლია Array.prototype.ახალი ფუნქციის სახელი.

###################################################################################################################################################

HTML ელემენტებიც წარმოადგენენ ობიექტებს, რომელთაც აქვთ თავიანთი property - ები და მეთოდები და შესაბამისად თავიანთი პროტოტიპებიც.

ამასთანავე ფუნქციაც არის ობიექტი, რომელსაც აქვს თავისი პროტოტიპი, სადაც გაწერილია სხვადასხვა ფუნქციები, რომელთა გამოყენებაც შეგვიძლია ამ ფუნქციაზე.

###################################################################################################################################################

Classes
#######

კლასიც, ისევე როგორც, constructor function, წარმოადგენს ე.წ. Blueprint - ს, რომლის საშუალებითაც შეგვიძლია შევქმნათ ახალი ობიექტები(instance - ები).
კლასს, გააჩნია თავისი constructor ფუნქცია, რომელიც აუცილებლად უნდა იყოს მასში. თავდაპირველად გამოიძახება აღნიშნული constructor ფუნქცია. მეთოდები,
რომლებსაც დავწერთ constructor ფუნქციის გარეთ, შეინახება პროტოტიპში, შესაბამისად, მისი ცალკე პროტოტიპში შენახვა არ არის საჭირო.

Getters and Setters
###################

თითოეულ ობიექტში შეგვიძლია გამოვიყენოთ get და set. იმ შემთხვევაში, თუ ვიყენებთ get - ს, შეგვიძლია იქვე გავწეროთ მეთოდი, რომელიც დააბრუნებს ჩვენთვის სასურველ
მნიშვნელობას. მაგ: get latest() {return something}. ობიექტში getter - ის გაწერის შემდეგ, შეგვიძლია მას მივწვდეთ ისე, როგორც ვწვდებით ჩვეულებრივ property - ს
და არა როგორც ობიექტში გაწერილ მეთოდს. მაგ: console.log(account.latest). Set ის გაწერის შემთხვევაში, კი შეგვიძლი, რომელიმე კონკრეტულ property - ს
მივანიჭოთ ახალი value. ამისათვის, უნდა გავწეროთ setter. მაგ: set latest(mov) {this.movements.push(mov)}. მაგრამ, ობიექტის გარეთ აღნიშნულ სეთერს უნდა მივწვდეთ
როგორც property - ს და მას მნიშვნელობა კი არ უნდა გადავცეთ, არამედ იგი უნდა გავუტოლოთ ამ მნიშვნელობას: account.latest = 4564; Setter შეგვიძლია გამოვიყენოთ
ვალიდაციისთვის, მაგალითად, როდესაც სეთერს გავუტოლებთ კონკრეტულ მნიშვნელობას, იმ შემთხვევაში თუ აღნიშნული მნიშვნელობა იქნება ვალიდური, ობიექტის property - ს
გავუტოლებთ მას.

Static Method
#############

არსებობენ სტატიკური მეთოდები - აღნიშნული მეთოდები, განისაზღვრება პირდაპირ კონსტრუქტორ ფუნქციაში და შესაბამისად, არ განისაზღვრება პროტოტიპში. ამიტომაც, ამ კონსტრუქტორ ფუნქციის
instance - ებს არ აქვთ წვდომა აღნიშნულ მეთოდთან. იმისათვის, რომ მსგავსი ფუნქცია დავწეროთ კლასში, ამისათვის აუცილებელია კლასში გაწერილ მეთოდს, წინ დავუმატოთ static keyword.